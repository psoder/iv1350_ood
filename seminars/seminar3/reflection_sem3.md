# Reflection About Seminar 3

What are your conclusions about this seminar? Try to answer the following questions.

## Approximately how much time, including lectures and exercises, have you spent preparing for the seminar?

Since I did seminar 3, 4, and some of the higher grade tasks it's hard to approximate
how much time was spent on this seminar. I would guess that I've spent maybe 20
hours in total on writing (and rewriting) the program. However, that included quite
quite a lot of learning since I haven't used Kotlin previously. On the report
and documentation I would guess about 3-4 hours.

## What have you learned from the problems presented?

Honestly, probably nothing. It might be because I have programed a fair bit
previously and have come in contact with more or less all concepts in the course
(and the new ones are pretty simple).

One of the bigger insights I've gotten is that it's pretty pointless to draw
diagrams before coding. The problem with diagrams is that they're great for small
programs, but become pretty useless for larger systems since they become unreadable.

Another thing to be learned from this is that the object-orientedness of the program
creates a lot of useless code and makes it pretty dificult to grasp what's going
on in the program since the actual functionality behind something is burried in
an excesive amount of abstraction.

Also, most people write low quality code and don't write  README files with
instructions for how to actually run the program.

## What was difficult and what was easy?

The most dificult part was being concise, it's like Mark Twain said, "I didn't
have time to write a short letter, so I wrote a long one instead.". While I think
I've done a pretty good job of not having anything unecessary I know there's some
parts that could be simplified.

The easiest part was just writing the code. The actual functionality was proably
too simple, which resulted in the whole endevour feeling very similar to
[FizzBuzz: Enterprise Edition](https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition).

## How have you worked when solving the problems?

Mostly in small bursts. I started by creating a basic foundation (creating the layers).
After that I went thorugh the requirements and made things up as I realized they
were needed. It was a very iterative process and I had to go back and change the
things several times.

## What questions remain regarding the problems?

No.

## Do you have any suggestions regarding the course? Both suggestions for this course instance and for coming years are of interest

Make the task be a somewhat complex program so that it dosen't feel like using
an excavator to build a sand castle. One easy way of doing this is to require
all functionality in the requirements to be implemented and then some.
